

## Python 基本

### `import ` 引入模块

`import` 语句可以引入一下模块类型:
1. Python 标准库
2. 库函数
3. 自定义的 `.py` 文件
4. 其他第三方库

### `__name__` 属性
这通常用于判断一个 `.py` 文件是被当作脚本直接运行，还是被当作模块导入。

#### 作业模块调用(`import`)

语法: `__name__ = 模块名`
解释:当你通过 `import my_script` 在另一个文件中导入这个脚本时，`__name__` 的值就是该文件的文件名（即 `my_script`）。

#### 直接运行

语法: `__name__ = "__main__`
解释:当你直接执行这个文件（例如在命令行输入 `python my_script.py`）时，系统会将 `__name__` 赋值为字符串 `"__main__"`。

经典的程序入口判断:

```Python
if __name__ == "__main__":
```

### big data 大数据

**大量数据**概括得到的有用信息
> Python 是最热门的处理大数据工具

### 数据类型

- Python 中<mark style="background: #ADCCFFA6;">处理的一切都是对象</mark>
- 对象分成两类:
  1. 内置
  2. 非内置(由 `import` 引入的)
- Python 中可对变量直接赋值,无需声明--先存储值在内存中,变量指向这个值

### 特殊规则

- Python 可以支持任意大的整数
- 复数中，虚部为 1
  在 Python 中表示复数必须带 `j`。重点是，如果虚部是 1，**必须写 `1j`**

### `zip` 函数和 `map` 函数

这两个函数都有**懒惰求值**的特性,他们不会在内存中生成完整列表,而是生成一个对象(地址),直到明确要求查看时才会计算.两者都必须用 `list()` 或 `tuple()` 才能“打开”它们看结果

#### `zip()` 拉链函数

`zip('abcd', [1, 2, 3])`
**功能描述**：它像拉链一样，将左右两边的数据按顺序“对齐”缝合。
- 第一对：`'a'` 和 `1` → `('a', 1)`
- 第二对：`'b'` 和 `2` → `('b', 2)`
- 第三对：`'c'` 和 `3` → `('c', 3)`
输出结果: `[('a', 1), ('b', 2), ('c', 3)]`
> zip 会以短的一边为准,两一边多出来的元素被舍弃

<mark style="background: #ADCCFFA6;">zip 返回的是迭代器,用一次就空了</mark>

#### `map()`：映射函数

`map(str, range(5))`:它会将数据源里的每一个元素，依次通过前面的函数进行处理
- `str`：这是转换函数，指“转化为字符串”。
- `range(5)`：这是数据源，包含 `0, 1, 2, 3, 4` 这五个数字。


## 列表

### 列表的创建与删除

创建:
- 列举法:使用方括号 `[ ]`，内部元素用逗号 `,` 分开. e.g `x=[1,2,3]`
- 使用 `list` 函数:常用于把其他类型的数据（如元组、字符串）转换成列表。

删除:
- `del x`:把列表 x 从内存汇总删除

### 列表的使用

**列表访问 ** * **从左到右**：下标（Index）从 **0** 开始 * `x[0]` 代表第一个元素。

- **从右到左**：下标从 **-1** 开始。
    - `x[-1]` 代表最后一个元素（倒数第一个）。

### **列表排序**

  - **`x.sort(key, reverse=True)`**：
    - 这是**永久性排序**，会直接改变 `x` 的顺序。
    - `reverse=True` 表示**降序**（从大到小），默认是升序。
  - `x.reverse()`:把列表**倒序**.

区分:
`sorted()`:返回一个新的列表(排好序的)-->不会破坏原序列

| **特性**         | **list.sort() **              | **sorted() **                                   |
| ---------------- | ----------------------------- | ----------------------------------------------- |
| **对象**         | 只能用于**列表 (list)**       | 可用于**所有可迭代对象** (列表, 元组, 字符串等) |
| **返回值**       | **`None`** (没有返回值)       | **返回一个新的列表** (排好序的)                 |
| **对原数据影响** | **永久修改** ，**原列表变了** | **==不修改原数据==**，原列表保持不变            |
| **记忆口诀**     | **sort 只有动作，没有结果**   | **sorted 产生新结果，不伤原身**                 |


**列表切片操作**

- **语法**: `[start : end : step]`（起点 : 终点 : 步长）--> 起点终点都是指的是*下标 index*

### 列表推导式

基本公式:            $[\underbrace{x * x}_{\text{表达式}} \quad \underbrace{\text{for } x \text{ in range}(10)}_{\text{变量取值范围}} \quad \underbrace{\text{if } x > 5}_{\text{变量满足条件}}]$
e.g

```Python
xyList = [x*x + y*y for x in range(10) if x > 5 for y in range(12) if y < 4]
```
解释:它相当于先通过 `x` 的循环（找大于 5 的数），再在内部跑 `y` 的循环（找小于 4 的数），最后计算 `x² + y²`。


## 元组
- 创建用 `()`
- `y=(3,)` --创建一个只有 `3` 的[[元组]]
- 访问速度比[[列表]]快
- 元祖成员访问:都是在元祖中取出一个值
  - 函数 `next(对象)`:可以设定默认值
  - 方法: `__next__()`:直接报错

e.g.
```python
nums = (1, 2, 3) #元组(可迭代对象)
iter_nums=iter(nums)#把元组转换成迭代器
num=next(iter_nums)#取出一个元素
```

> 元组没有推导式
> 常见的推导式:
> - `[...]` 是列表推导式。
> - `{...}` 是集合或字典推导式。


## 集合

语法: `set()`

特点:自动去重复

集合运算:
- 差集 `-` : `A-B` 是减去 A 中 B 的部分
- 对称集 `^` : `A^B`:是只在 A 中或只在 B 中,但不同时在 A 和 B 中的元素
e.g. 
```Python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
A^B={1,2,5,6}
```


## 函数

### 匿名函数 `lambda` 表达式

`lamda` 表达式没有函数名,没有 `def`

定义: `f=lamda x,y,z : x+y+z`
> `x,y,z` 是变量, `x+y+z` 是输出表达式

调用: `f(1,2,3)`,**实参输入**

## 循环控制

Break 与 Continue 的区别:

- **`break` (中断)**：直接**跳出整个循环**，不再执行循环剩余的次数。循环彻底结束。
- **`continue` (继续)**：只**跳过当前这一次**循环的剩余语句，直接开始下一次循环


## `yield` 语句
**看到 `yield` 关键字：** 马上反应出 **"生成器" (Generator)--> 节省内存,懒惰求求值节省不必要的开支**.        生成器函数用 yield 语句代替一般函数的 return 语句.

**特点：** 执行到 `yield` 会**暂停**，记住当前的变量状态（比如循环到了第几次），等待下一次召唤

好处:
- **产生的新特性：**
    
    - **状态保持（挂起与恢复）：** `yield` 会让函数暂停执行（挂起），并保存当前的局部变量和执行位置。下一次调用（如使用 `next()`）时，函数会从上次暂停的地方继续执行，而不是重新开始 。
        
    - **返回迭代器：** 生成器函数调用时不会立即执行代码，而是返回一个生成器对象（迭代器），只有在需要数据时才进行计算。
        
- **有什么好处：**
    
    - **节省内存（核心好处）：** 生成器不需要像列表那样一次性把所有数据生成并存储在内存中，而是“用一个生成一个”（流式处理）。对于处理大量数据或无限数据流非常高效 。
        
    - **懒惰求值：** 只有在被索取数据时才计算，避免了不必要的计算开销 。



---

## 对象

类的定义: 
```Python
class name(父类):
	变量
	函数
	方法
```

- `self`:所有方法的第一个参数一般都是 `self`,核心是`self` 代表**类的实例对象本身**。它用于在类的方法内部访问该对象的属性（变量）和其他方法。
	- `self` 实际代表**对象实例**
	- 在类内部,实例化过程传入的数据实际上是赋值给变量 self
- 对象调用方法: `<对象>.<方法>(参数)`
e.g.
```Python
gCar=GasCar("BYD")	#创建一个对象
gCar.run(200,0)#	#对象调用函数

#实际上执行的是GasCar.Run(gCar, 200.0)
```

### 特殊方法

- 构造函数 `__init__()`:初始化
- 析构函数 `__del__()` : 删除对象,收回对象空间

### 多继承

- Python 中一个类可以继承多个父类,多个父类含有相同的变量和方法
继承两个父类 `Vehicle` 和 `GasPower`
```Python
class GasCar(Vehicle, GasPower):	
```

---

## 字符串

- 一对单引号或双引号表示
- 一对三单引号或三双引号表示:
	- 可表示**多行字符串**
	- **三单引号的字符串若没有赋值给变量,就会看注释**

多行字符串实例:
```Python
multi_str = '''这是第一行
这是第二行
这是第三行'''
```

字符串的序号可正可负:
- 正递增序号从左到右,从 `0` 开始递增
- 反向递增序号从右到左,从 `-1` 开始递增
```
	-->012345
str="中国山东烟台"
	-6-5-4-3-2-1<--
```

使用 `[]` 可以获取一个字符或多个字符,切片语法 `[start:end]`。索引从 0 开始。
> 以索引为标准,并且 *左闭右开*

```
str="中国山东烟台"
d[0]="中"
d[0:3]="中国山"
```

### 特殊字符

- `\` 转义符:转译成特殊字符原本的东西
- 在字符串之前加 `r` 或 `R` 表示原始字符串,一般用于转义字符表示原始的意思.

```Python
# 加r后，\n、\t都按字面显示
s2 = r"C:\new\test.txt"
#输出:C:\new\test.txt
```

特殊函数:
- `ord()` 接收一个**单个字符**，返回该字符对应的**Unicode 编码（整数）**
- `chr()`:接收一个**Unicode 编码（整数）**，返回该编码对应的**单个字符（长度为 1 的字符串）**

e.g.
```
ord('1')---> 49
chr(49)---> 1
```

### format `格式化`
[[str.format()方法]]

格式控制语法:

#### **精度与数字类型**:

| **场景**     | **代码示例**                | **结果**              | **说明**                     |
| ------------ | --------------------------- | --------------------- | ---------------------------- |
| **保留小数** | `f"{3.14159:.2f}"`          | `'3.14'`              | `.2f` 表示保留2位浮点数      |
| **百分比**   | `f"{0.85:.1%}"`             | `'85.0%'`             | 自动乘100并加%，`.1`为小数位 |
| **千分位**   | `f"{1000000:,}"`            | `'1,000,000'`         | 使用逗号作为分隔符           |
| **科学计数** | `f"{1000:.2e}"`             | `'1.00e+03'`          | 科学计数法                   |
| **进制转换** | `f"{255:x}"` / `f"{255:b}"` | `'ff'` / `'11111111'` | Hex(16进制) / Binary(2进制)  |

####  对齐与填充

语法：`:[填充字符][对齐方式][总宽度]`

```python
text = "Hi"

# 1. 右对齐，宽度10，默认空格填充
print(f"|{text:>10}|")  
# 输出: |        Hi|

# 2. 居中对齐，宽度10，使用 '=' 填充
print(f"|{text:=^10}|") 
# 输出: |====Hi====|

# 3. 左对齐，宽度10，使用 '*' 填充
print(f"|{text:*<10}|") 
# 输出: |Hi********|
```


### 常用方法

- `find()` 返回首次出现的位置(下标)
- `rfind()` 返回最后出现的位置(下标)
- `index`:返回首次出现的位置(下标)
- `rindex`:返回最后一次出现的位置(下标)
> 当子串不存在的时候:
> - `find()` / `rfind()` 会返回 `-1`（表示没找到）；
> - `index()` / `rindex()` 会直接**报错**（抛出 `ValueError`）


| `find()`     | `index()`    |
| ------------ | ------------ |
| 找不到返回-1 | 找不到会报错 |


- 字符串拼接 `.join()`
`指定分隔符.join(字符串变量/可迭代对象)`
- **指定分隔符**：是一个字符串（比如`","`、`"-"`、空字符串`""`），会插入到每个元素之间；
- **字符串变量 / 可迭代对象**：一般是列表或元组

e.g.
```Python
# 用逗号作为分隔符，连接列表里的元素
li = ["a", "b", "c"]
result = ",".join(li)
print(result)  # 输出："a,b,c"

# 用空字符串作为分隔符（直接拼接）
result2 = "".join(li)
print(result2)  # 输出："abc"

# 用短横线作为分隔符
result3 = "-".join(li)
print(result3)  # 输出："a-b-c"
```

---

## 正则表达式

真题模版:
```python
# 比如：把匹配到的第2组转为小写
re.sub(r'(\w)(\w+)(\w)', lambda x: x.group(1) + x.group(2).lower() + x.group(3), s)
```

### 基本语法

| **符号** | **描述**                       | **等价于**      |
| -------- | ------------------------------ | --------------- |
| `\d`     | 匹配数字 (Digit)               | `[0-9]`         |
| `\D`     | 匹配非数字                     | `[^0-9]`        |
| `\w`     | 匹配字母、数字、下划线 (Word)  | `[a-zA-Z0-9_]`  |
| `\W`     | 匹配非字母数字下划线           | `[^a-zA-Z0-9_]` |
| `\s`     | 匹配空白字符 (空格、Tab、换行) | `[ \t\n\r\f]`   |
| `\S`     | 匹配非空白字符                 |                 |

| **符号** | **描述**                       | **例子**        | **匹配结果**              |
| -------- | ------------------------------ | --------------- | ------------------------- |
| `.`      | 匹配除换行符以外的任意字符     | `a.c`           | `abc`, `a@c`, `a c`       |
| `^`      | 匹配字符串的**开头**           | `^H`            | 匹配 `Hello` 中的 `H`     |
| `$`      | 匹配字符串的**结尾**           | `d$`            | 匹配 `World` 中的 `d`     |
| `*`      | 前面的字符出现 **0 次或多次**  | `ab*`           | `a`, `ab`, `abbb`         |
| `+`      | 前面的字符出现 **1 次或多次**  | `ab+`           | `ab`, `abbb` (不匹配 `a`) |
| `?`      | 前面的字符出现 **0 次或 1 次** | `ab?`           | `a`, `ab`                 |
| `        | `                              | 逻辑**或** (OR) | `a                        |
| `\`      | 转义字符，用于匹配特殊符号本身 | `\.`            | 匹配字符 `.`              |

数量和范围
- **`{n}`**: 精确匹配 n 次。
    
    - `\d{3}` → 匹配连续 3 个数字 (e.g., `123`)。
        
- **`{n,}`**: 至少匹配 n 次。
    
- **`{n,m}`**: 匹配 n 到 m 次。
    
- **`[]` (字符集合)**: 匹配方括号内的任意一个字符。
    
    - `[abc]` → 匹配 `a` 或 `b` 或 `c`。
        
    - `[a-z]` → 匹配任意小写字母。
        
- **`[^]` (排除集合)**: 匹配**不**在方括号内的字符。
    
    - `[^0-9]` → 匹配任意非数字字符。

边界匹配:**`\b` (Word Boundary)**: **重点**。匹配单词的边界。
- _例子_: `\bPy\b` 只能匹配 `"Py"`，不能匹配 `"Python"` 中的 `"Py"`。

### 分组

在 `re.sub` 和信息提取中非常关键
- **`(...)`**: 捕获组。将括号内的正则视为一个整体，并保存匹配结果。
    - 可以通过 `match.group(1)` 获取第 1 个括号匹配的内容。
        
- **`(?P<name>...)`**: 命名组。给分组起个名字，可以通过 `match.group('name')` 获取。

### 贪婪匹配

- **贪婪模式 (默认)**: 尽可能多地匹配字符。
    
    - 正则: `a.*b`
    - 字符串: `aabab`
    - 结果: `aabab` (从第一个 a 匹配到最后一个 b)
- **非贪婪模式 (懒惰模式)**: 在量词后加 `?`，尽可能少地匹配。
	- 正则: `a.*?b`
	- 字符串: `aabab`
	- 结果: `aab` (匹配到第一个 b 就停止)

### 相关查找方法

- `search(pattern,string)`: string 中 pattern 匹配的**第一个位置**(全局找)
  返回:第一个位置匹配的对象
- `match(pattern,string)` : 从**第一个字符开始匹配**,只有开头部分符合返回匹配结果(只看从开头匹配的)

```Python
import re
s = "abc123"
pattern="\d+"
print(re.match(pattern, s))	#None
print(re.search(pattern, s))	#123
```

- `fullmatch(pattern,string)`:**整个字符串**和模式完全一致（无多余）
- `findall()`:查找所有符合模式的内容返回列表
- `sub(pattern,repl,string)`:用  `repl`  替换掉匹配的字符串


| `match()`    | 只看开头对不对，后面不管         |
| ------------ | -------------------------------- |
| `search()`   | 扫一遍全文，找到第一个对的就行   |
| `fullmatc()` | 从头到尾都得对，多一个字符都不行 |

---

## 文件操作

处理文件通用步骤:
1. 打开文件
2. 操作文件(读/写)
3. 关闭文件

### 打开文件

使用内置函数 `open`
语法: `file_obj = open(file_path, mode, encoding=None)`

模式:
第一个字母:
1. `r` 读
2. `w`:写
3. `a`:末尾追加
4. `x`:创建新文件进入写模式
5. `+`

第二个字母:
1. `t`:文本模式(默认)
2. `b`:二进制模式,用于处理非文本文件
> 当文件打开是二进制模式,若要对文件写入字符串 `s`,要先对其编码 `s.encode('utf-8')`
> 而默认打开文本模式,则无需编码.

### 读取文件
- `read()`:返回整个文件的字符串,若传入参数如 `10` 就会读取前 10 个字符\
- `readlines`:每一行作为列表的一个元素

### 写入文件
- `write()` 写入文本
- `writelines(lineslist)`:写入列表 `lineslist` 所有字符串

### 上下文管理语法
`with` 是上下文管理语法,==核心作用是**自动管理资源的创建和释放**,即自动关闭文件==

e.g.
```Python
with open("test.txt", "r") as f:
	content=f.read()
```

### CSV 文件
CSV 本质是一种纯文本文件,用 `,` 作为数据的分隔符

核心特点
- 值无类型,所有值都是字符串
- 每行列数相同,第一行是标题(列名)
- **数据项没有固定宽度**,用于大数据存储处理

example:
```
姓名,年龄,班级
张三,18,高一1班
李四,17,高一2班
```

#### 文件读取

- `csv.reader()` 获取 csv 文件的每行数据(<mark style="background: #D2B3FFA6;">每行是一个列表</mark>)

实例:
```Python
import csv
# 打开CSV文件
with open("data.csv", "r", encoding="utf-8") as f:
    reader = csv.reader(f)  # 创建读取器
    for row in reader:      # 遍历读取每行
        print(row)  # 输出：['姓名', '年龄', '班级']、['张三', '18', '高一1班']等
```

- `csv.DictReader()` 作用与 `csv.reader()` 类似,但是每行数据被<mark style="background: #D2B3FFA6;">包装成字典</mark>(每一行都是一个字典,键是 CSV 的标题行,值是对应列的内容)

#### 文件写入

-  `csv.writer()` + `writerow()`
`csv.writer()` 创建一个 “CSV 写入器”，`writerow()` 用于**写入一行数据**（参数是**列表**，对应一行的各列值）

实例:
```Python
with open("output.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)          # 创建写入器
    writer.writerow(["姓名", "年龄"])  # 写入标题行
    writer.writerow(["张三", "18"])   # 写入数据行
```


- `csv.DictWriter()`

```Python
dict_writer.writerow({"姓名": "李四", "年龄": "17"})
```

---
## os 库
`os` 库主要用于与操作系统进行交互（文件管理、路径操作）

| **分类**                 | **函数/方法**          | **功能描述**                            |     |
| ------------------------ | ---------------------- | --------------------------------------- | --- |
| **工作目录操作**         | `os.getcwd()`          | 获取当前 Python 脚本工作的目录路径      | ✅   |
|                          | **`os.chdir(path)`**   | **切换当前工作目录到指定路径**          | ✅ ✅ |
| **文件与目录管理**       | `os.listdir(path)`     | 返回指定目录下的所有文件和子目录列表    | ✅   |
|                          | `os.mkdir(path)`       | 创建一个新的文件夹（单层目录）          |     |
|                          | `os.remove(path)`      | 删除指定的文件（不能删除文件夹）        | ✅   |
|                          | `os.rmdir(path)`       | 删除指定的**空**文件夹                  | ✅   |
| **路径处理 (`os.path`)** | `os.path.exists(p)`    | 判断路径（文件或文件夹）是否存在        |     |
|                          | `os.path.join(p1, p2)` | 智能拼接路径（自动处理斜杠 `/` 或 `\`） |     |
|                          | `os.path.isfile(p)`    | 判断指定路径是否为一个**文件**          |     |
|                          | `os.path.isdir(p)`     | 判断指定路径是否为一个**目录**          |     |
|                          | `os.path.splitext(p)`  | 分离文件名与扩展名（如 `.jpg`, `.py`）  |     |
| **系统交互**             | `os.system(cmd)`       | 运行系统终端命令（如 `cls` 清屏）       |     |
|                          | `os.stat()`            | 获取文件/目录的状态信息                 | ✅   |




---

## 异常处理

异常处理常用语法:

### `try-except` 语句

捕获指定类型的异常,并处理
语法:
```Python
try:
    <检测语句>  # 可能出错的代码（比如读取文件、计算）
except <错误类型> as e:
    <处理异常>  # 出错时执行的代码（比如打印提示）
```

先执行 `try` 里的代码,若出错且错误类型匹配 `except`，执行 `except` 里的处理代码.

### 多个 `except`

对多个不同类型的异常处理
语法:
```Python
try:
    <检测语句>
except <错误类型1> as e1:
    <处理e1的代码>
except <错误类型2> as e2:
    <处理e2的代码>
```
> 后面也可以接 `finally`,一定会执行语句

### 必须执行处理 `try-finally` 语句

无论 `try` 是否引发异常, `finally` 里的代码一定会执行
语法:
```Python
try:
    <检测语句>
except <错误类型> as e:
    <处理异常>
finally:	#一定会执行
    <必执行的代码>  # 比如关闭文件、释放资源
```

### 无异常执行：`try-except-else` 语句

`else` 里的代码，只有当 `try` 里的代码**完全没出错**时才执行；
语法:
```Python
try:
    <检测语句>
except <错误类型> as e:
    <处理异常>
else:
    <没出错时执行的代码>
```

区分:

| `try-except-else`                              | `try-finally`                      |
| ---------------------------------------------- | ---------------------------------- |
| 只有在**==没有异常的时候==**才执行 `else` 代码 | 无论有无异常,都执行 `finally` 代码 |
|                                                |                                    |
## HTML

HTML 的最外层框架是:
```html
<html>
  <body>
    <!-- 网页的内容（文字、图片、表格等）都写在这里 -->
  </body>
</html>
```

### 常见的 HTML 标签

#### h 标签:标题标签

作用:定义不同层级的标题
写法:
```html
<h1>标题1（最大）</h1>
<h2>标题2</h2>
...
<h6>标题6（最小）</h6>
```

#### p 标签:段落标签
作用:定义一个段落
`<p>这是一段文字，会自动作为一个段落显示。</p>`

#### a 标签:超链接标签
作用:定义一个可以点击的链接,跳转到其他网页/地址

#### table/tr/td 标签:表格标签
作用:定义表格（`table` 是整个表格，`tr` 是一**行**，`td` 是单元格）
写法:
```html
<table>
  <tr> <!-- 第一行 -->
    <td>单元格1内容</td>
    <td>单元格2内容</td>
  </tr>
  <tr> <!-- 第二行 -->
    <td>单元格3内容</td>
    <td>单元格4内容</td>
  </tr>
</table>
```

#### div 标签:块容器标签
作用:建造一个块,分块处理,中间可以是上述的所有东西
写法:
```html
<div>
	...
</div>
```


| 标签  | 标签内容           |
| ----- | ------------------ |
| h     | 标题               |
| a     | 链接               |
| p     | 段落               |
| div   | 块                 |
| table | 整个表格           |
| tr    | 表格的一行         |
| td    | 一行中的一个单元格 |
| ol    | 有序列表           |
| ul    | 无序列表           |


## urllib 库

urllib 库是 Python 的自带库,用于网络爬取数据

### 重要方法
- `urllib.request` : 发送请求,返回结果是 `response` 对象
- `urllib.response`:网页应答
- `urllib.parse`:处理 URL 的编码解码,拼接
- `urllib.robotparser`:判断目标网站是否允许爬虫
- `urllib.error`:定义请求过程中可能出现的错误

### get 方式传递参数

get 请求的参数是直接拼接在 URL 后面的. 
语法:
```Python
urllib.request.Request(网页URL, headers=浏览器参数)
```
对参数与网页绑定传送

例如:
```Python
params = {"wd": "Python"}	#定义参数
# 2. 把参数编码后拼接到URL
url = f"https://www.baidu.com/s?{urllib.parse.urlencode(params)}"
```

### POST 方式传递参数

POST 请求的参数是放在请求体里的,不显示在 URL 中
语法:
```Python
urllib.request.Request(网页URL, data=编码后的参数, headers=浏览器参数, method="POST")
```
- `data`:参数先转成**字节类型**(`urllib.parse.urlencode().encode("utf-8")`)

### 两者区别

|              | get 方式                | POST 方式                            |
| ------------ | ----------------------- | ------------------------------------ |
| 参数位置     | 拼接在 URL 后面         | 放在请求体内                         |
| Request 参数 | 只用 `url` 和 `headers` | 还需要传入 `data` 和 `method="POST"` |


## requests 库(选看)
比 urllib 更简洁，自动处理连接复用和 URL 编码，是目前 Python 最主流的 HTTP 库。

### 主要的请求方法

| **方法** | **语法示例**             | **考点备注**    |
| -------- | ------------------------ | --------------- |
| **GET**  | `r = requests.get(url)`  | 参数用 `params` |
| **POST** | `r = requests.post(url)` | 参数用 `data`   |

### 常见方法

| **属性/方法**         | **说明**             | **关键点 (记忆技巧)**                                         |
| --------------------- | -------------------- | ------------------------------------------------------------- |
| **`r.status_code`**   | HTTP状态码           | `200` 表示成功，`404` 失败。常用于 `if r.status_code == 200:` |
| **`r.text`**          | 响应内容的**字符串** | 用于**文本/HTML**。自动根据 `r.encoding` 解码。               |
| **`r.content`**       | 响应内容的**二进制** | 用于**图片/视频/音频**。保存文件时必须用 `wb` 模式。          |
| **`r.encoding`**      | 猜测的编码方式       | 可以手动赋值修正乱码：`r.encoding = 'utf-8'`                  |
| `r.apparent_encoding` | 备选编码方式         | 更加准确的编码猜测（分析内容得出），比 encoding 慢。          |
| `r.json()`            | JSON解码器           | 如果网页返回的是 JSON 格式，直接转换成 Python 字典。          |

## Beautiful Soup

Beautiful Soup 核心作用是解析爬取到的 HTML 网页源码,提取需要的数据(提取纯文本,表格图片等内容)

### 初始化语句

```Python
Soup = BeautifulSoup(html, 'html.parser')
```
- `html`:爬取的网页源码字符串
- `html.parser`:指定解析器
- `soup`:执行后返回结构化的 HTML 对象,可以通过 `soup` 提取数据

### 提取标签/属性

#### 获取标签的内容和指定属性

- `Soup.title`:获取网页的 `<title>` 标签对象
	- `Soup.title.name`:获取 `<title>` 标签的标签名 `
	- `Soup.title.text`:获取 `<title>` 标签内的纯文本内容
	- `Soup.title.string`:获取 `<title>` 标签的内容 
- `Soup.a.attrs`: 获取标签中第一个 `<a>` 标签的所有属性
- `Soup.a["class"]`: 获取第一个 `<a>` 标签的 class 属性值
- `Soup.find_all('a')`:查找页面中所有 `<a>` 标签,返回的是标签对象的链表

### 爬虫流程

- 分析网页,找到要爬取的内容的标签/id
- 爬取页面,保存为文本文件(用 `urllib` / `requests` 获取网页源码)
- 解析页面
   - HTML 代码:网页解析器,如 `Beautiful Soup`
   - JSON 数据:用 Python 自带的 `json` 模块
   - 二进制数据:用 `wb` 模式写入文件
   -  程序结构设计:
      - 获取网页内容 `html = askURL(url)` (askURL 为封装的请求函数)
      -  提取整理数据 `data_list=getData(html)`
      - 保存数据

## 详细爬虫流程

```python
import requests
from bs4 import BeautifulSoup

def get_data(url):
    try:
        # 1. 发送请求 (Requests)
        # 考点：参数是url，返回是response对象
        r = requests.get(url)  # [cite: 392, 667, 845]
        
        # 2. 处理编码 (Encoding) - 可选但重要
        # 考点：如果不写这行，中文可能会乱码
        r.encoding = r.apparent_encoding 
        
        # 3. 获取文本 (Text)
        # 考点：r.text 获取网页源代码字符串
        demo = r.text  
        
        # 4. 解析网页 (BeautifulSoup)
        # 考点：两个参数，第一个是网页文本，第二个是解析器 "html.parser"
        soup = BeautifulSoup(demo, "html.parser") 
        
        # 5. 查找标签 (Find_all)
        # 考点：返回的是一个列表(List)，通常查找 'a' 标签
        # 比如：查找所有超链接
        links = soup.find_all('a') 
        
        # 6. 循环提取数据 (Loop & Extract)
        for link in links:
            # 提取链接地址 (href属性) -> 考试最爱考！
            href = link.get('href') 
            
            # 提取标签内的文字 (比如 <a>新闻标题</a>)
            title = link.text # 或者 link.string 
            
            print(f"链接: {href}, 标题: {title}")
            
    except:
        print("爬取失败")

# 调用
url = 'http://python123.io/ws/demo.html' # [cite: 665, 844]
get_data(url)
```

根据你的真题卷，考试常在以下几个地方挖空，请重点记忆：

1. **发送请求：**
    - 题目会问：`r = ________`
    - 答案：`requests.get(url)`
2. **创建 Soup 对象：**
    - 题目会问：`soup = ________`
    - 答案：`BeautifulSoup(demo, "html.parser")` (注意引号和 `demo` 变量名)
3. **查找所有标签：**
    - 题目会问：`for link in ________:`
    - 答案：`soup.find_all('a')` (注意是 `find_all` 不是 `find`，因为后面跟了 `for` 循环)
4. **获取属性值（最容易错）：**
    - 题目会问：`print(________)` (要求打印链接地址)
    - 答案：`link.get('href')` (切记：获取属性用 `.get('属性名')`，获取内容用`.text`)

为了保险，请记住 `urllib` 对应的这一句替换：

- **Requests 写法：** `r = requests.get(url)`
    
- **Urllib 写法：** `response = urllib.request.urlopen(url)`
    
- **读取内容：** `html = response.read()`

## Scrapy

### 核心命令流程

- `scrapy startproject <name1>`:生成一个 name1 的文件夹,包含 Scrapy 项目的基础文件/目录
- `scrapy genspider <name2> 网址` 生成一个具体的爬虫文件
- 编写代码
- `scrapy crawl name2`: 运行爬虫 


## 🐼 Pandas

Pandas 是 Python 的数据分析库，提供 3 种结构化数据容器

### Series 向量

包含索引和值
示例：`x = [1,4,5,7]` → 用`pd.Series([1,4,5,7])`创建

### 二维数组：DataFrame

带行索引 + 列名的表格型结构”(类似 Excel 表格)
类似表格的结构:

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 0   |     |     |     |
| 1   |     |     |     |
| 2   |     |     |     |
| 3   |     |     |     |

### 基础操作

#### 查看基础信息

- `df.index`：查看 DataFrame 的**行索引**；
- `df.columns`：查看 DataFrame 的**列名**；
- `df.values`：查看 DataFrame 的**所有值**（返回二维数组）

#### 查看统计信息

- `df.describe()`：自动计算数值列的统计指标（平均值、方差、最大值、最小值等）

### 缺失值处理
- `df.dropna()`：删除包含 ** 缺失值（空值）** 的行，得到无缺失值的数据集。

### 数据处理

`df.groupby("分组列")["目标列"].操作()`:根据分组对目标进行处理把符合的统计成一个组,操作常见为 count 统计,统计组内的数量.返回一个 `DataFrame`,行是分组,列是操作的结果

`nlargest()` 作用:选出数值最大的前 N 行
语法格式: `df.nlargest(n, columns, keep='first')`
- **`n` (必须)**: 你想要获取几行数据（比如前 4 名，就填 4）。
- **`columns` (必须)**: 根据哪一列（或哪几列）的数值来排序。
- **`keep` (可选)**: 如果遇到数值相同的情况怎么处理？
    - `'first'` (默认): 保留先出现的那个。
    - `'last'`: 保留后出现的那个。
    - `'all'`: 如果并列，全保留。

`nsmllest()` 作用:返回数值最小的前几行



---

## matplotlib 绘图

matplotlib 是 Python 的绘图扩展库常用模块是  `pylot` (常用,简写成 `plt`)

### 重要图形对应的函数

| 折线图 | `plot()`    |
| ------ | ----------- |
| 散点图 | `scatter()` |
| 柱状图 | `bar()`     |
| 饼图   | pie()       |

### 一个函数图的绘制步骤
以函数 `s=sint(t)` 为例
1. 定义自变量范围: `plt.arange(起点,终点,步长)`
2. 设置函数: `s=np.sin(t)`
3. 绘制图形:传入自变量加因变量
   `plt.plot(t, s, label="sin(t)", color="blue") # t是x轴，s是y轴`
4. 设置坐标轴标题: `plt.xlabel("时间 t") plt.ylabel("函数值 s=sin(t)")`
5. 设置图的标题: `plt.title("xxx")`
6. 图中文字/样式设置
7. 显示图形: `plt.show()`

## GUI 编程(上课没讲但考题有)

`tkinter` 是 Python 的 **标准库 (Standard Library)**。无需安装, python 自带


常见的事件绑定:

**语法**: `widget.bind(event, handler)`,把事件和函数关联起来
- **`<Button-1>`**：鼠标**左键**单击 (1代表左)
- **`<Button-2>`**：鼠标中键单击
- **`<Button-3>`**：鼠标**右键**单击 (3代表右)
- **`<Double-Button-1>`**：鼠标左键双击

e.g. 
真题:语句 `root.bind('<Button-1>', printEvent)` 的执行结果是将主窗口root与单击鼠标左键的事件处理函数printEvent进行 (**绑定**) 。"

---
## 查漏补缺

- **Find vs Index**的区别[[#常用方法]]
- 正则表达式函数的区别: [[#相关查找方法]]
- Scrapy 的创建命令: [[#核心命令流程]]
- 散点图柱状图的函数名称: [[#重要图形对应的函数]],记住饼图是 `pie()`
- python 中表示逻辑关系: `and or not`
